name: Sync Selected Tasks (Range)

on:
  workflow_dispatch:
    inputs:
      start_task:
        description: "Start task number (e.g., 23 for T-023)"
        required: true
        default: "23"
      end_task:
        description: "End task number (e.g., 27 for T-027)"
        required: true
        default: "27"
      delay_ms:
        description: "Delay between operations (ms)"
        required: false
        default: "1000"

jobs:
  sync-range:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - uses: actions/checkout@v4

      - name: Sync task range from tasks.md
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const md = fs.readFileSync('tasks.md', 'utf8');
            const lines = md.split('\n');

            const startNum = parseInt('${{ github.event.inputs.start_task }}');
            const endNum = parseInt('${{ github.event.inputs.end_task }}');
            const delayMs = parseInt('${{ github.event.inputs.delay_ms }}');

            console.log(`Syncing tasks T-${startNum.toString().padStart(3, '0')} to T-${endNum.toString().padStart(3, '0')}`);
            console.log(`Using ${delayMs}ms delays between operations`);

            // Add delay function
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

            // Map phase headers -> milestone titles
            let currentMilestone = null;
            const allTasks = [];

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              // Match "## Phase X: Name - ..."
              const phaseMatch = line.match(/^##\s+(Phase\s+\d+):\s+(.+?)\s*(?:-|—)/);
              if (phaseMatch) {
                currentMilestone = `${phaseMatch[1]}: ${phaseMatch[2].trim()}`;
                continue;
              }

              // Match "- [ ] (T-001) **Task Title**"
              const m = /^- \[ \] \((T-\d{3}[a-z]?)\) \*\*(.+?)\*\*/.exec(line);
              if (m) {
                const id = m[1];
                const title = `(${id}) ${m[2]}`;

                // Extract numeric part for filtering
                const numMatch = id.match(/T-(\d{3})/);
                const taskNum = numMatch ? parseInt(numMatch[1]) : -1;

                // Capture indented body until next top-level task
                let j = i + 1, bodyLines = [];
                while (j < lines.length && !lines[j].match(/^- \[ \] \(\T-\d{3}[a-z]?\) \*\*/)) {
                  bodyLines.push(lines[j]); j++;
                }
                const body = bodyLines.join('\n');

                allTasks.push({ id, title, body, milestone: currentMilestone, taskNum });
              }
            }

            // Filter to requested range
            const tasks = allTasks.filter(t => t.taskNum >= startNum && t.taskNum <= endNum);
            console.log(`Found ${tasks.length} tasks in range: ${tasks.map(t => t.id).join(', ')}`);

            if (tasks.length === 0) {
              console.log('No tasks found in specified range!');
              return;
            }

            async function ensureMilestone(title) {
              if (!title) return undefined;
              const { data: milestones } = await github.rest.issues.listMilestones({
                owner: context.repo.owner, repo: context.repo.repo, state: 'open'
              });
              let m = milestones.find(x => x.title === title);
              if (!m) {
                const created = await github.rest.issues.createMilestone({
                  owner: context.repo.owner, repo: context.repo.repo, title
                });
                m = created.data;
                console.log(`Created milestone: ${title}`);
              }
              return m.number;
            }

            for (const t of tasks) {
              console.log(`Processing ${t.id}...`);

              const labels = [];
              if (t.milestone?.match(/^Phase 0/)) labels.push('phase-0');
              if (t.milestone?.match(/^Phase 1/)) labels.push('phase-1');
              if (t.milestone?.match(/^Phase 2/)) labels.push('phase-2');
              if (t.milestone?.match(/^Phase 3/)) labels.push('phase-3');
              if (t.milestone?.match(/^Phase 4/)) labels.push('phase-4');

              // Search by exact title to avoid duplicates
              const { data: search } = await github.rest.search.issuesAndPullRequests({
                q: `repo:${context.repo.owner}/${context.repo.repo} in:title "${t.title}"`
              });
              let issueNumber = search.items?.find(i => i.title === t.title)?.number;

              const milestoneNumber = t.milestone ? await ensureMilestone(t.milestone) : undefined;

              const issueBody = t.body + '\n\n_Checklist:_\n- [ ] Implementation complete\n- [ ] Tests passing\n- [ ] Home inspection >90%\n- [ ] Git commit with ' + t.id + ' reference';

              if (!issueNumber) {
                const created = await github.rest.issues.create({
                  owner: context.repo.owner, repo: context.repo.repo,
                  title: t.title,
                  body: issueBody,
                  labels,
                  milestone: milestoneNumber
                });
                issueNumber = created.data.number;
                console.log(`✅ Created issue #${issueNumber}: ${t.title}`);
              } else {
                await github.rest.issues.update({
                  owner: context.repo.owner, repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: issueBody,
                  labels,
                  milestone: milestoneNumber
                });
                console.log(`📝 Updated issue #${issueNumber}: ${t.title}`);
              }

              // Delay between operations
              await delay(delayMs);
            }

      - name: Done
        run: echo "✅ Selected task range synced successfully!"